# Java基础

1. final finally finalize 的区别

   > final修饰符，用于修饰方法变量类。修饰方法无法重写，修饰属性无法更改，修饰类无法继承
   >
   > finally 异常处理关键字之一，代表一定（基本）会执行。
   >
   > finalize是方法名，[java](https://www.baidu.com/s?wd=java&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)技术允许使用finalize方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize方法以整理[系统资源](https://www.baidu.com/s?wd=%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)或者被执行其他清理工作。

2. 强引用 、软引用、 弱引用、虚引用

   > 

3. Java反射

   > JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

4. Object 对象的方法有哪些？分别有什么作用？该什么场景用？

   > 1. **Object()：** Object类中并没有显式声明该构造方法，其是由编译器自动为其创建的一个不带参数的默认构造器。
   > 2. **registerNatives()：**用于注册本地方法，即将本地用C/C++实现的方法映射到Java中的本地（native）方法，实现方法命名的解耦。
   > 3. **getClass():**用于获取此Object的运行时类对象，运行时类是 Java 反射机制的源头。
   > 4. **hashCode():**用于返回对象的哈希值，哈希值是一个可正可负的整数值。
   > 5. **equals():**用于判断两个对象的引用是否相等，而实际开发中常需要重写该方法以比较两个对象的具体内容是否相等。
   > 6. **clone():**用于创建并返回此对象的一个副本，其实质上是一种「浅拷贝」。
   > 7. **toString():**用于返回该对象的字符串表示，建议所有子类均重写该方法，以返回该对象中各属性值的字符串表示。
   > 8. **notify():**用于唤醒一个在此对象监视器上等待的线程，由JVM决定唤醒哪个等待线程，与线程的优先级无关。
   > 9. **notifyAll():**用于唤醒所有在此对象监视器上等待的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。
   > 10. **wait(long timeout):**导致当前线程释放所持有对象的锁（线程暂停执行），进入在对象监视器上等待的状态，直到达到最长等待时间（timeout）或其他线程调用notify()或notifyAll()方法
   > 11. **wait(long timeout, int nanos):**最长等待时间为「1000000 * timeout + nanos」。
   > 12. **wait():**未指定最长等待时间。
   > 13. **finalize():**垃圾回收器在准备回收对象前，会先调用该方法；子类可通过重写该方法，以在垃圾回收前整理系统资源或执行其他清理操作。
   >

5. Integer 的常量缓存池

   > 常量缓存池的大小为一个字节（-128~127）

6. Java 特性？分别是什么意思，各举出一个例子

   > 特性是：封装、继承、多态。
   >
   > 1. **封装 ：**
   > 2. **继承：**
   > 3. **多态：**

7. 重载重写的区别？

   > **方法重写**：也叫子类的方法覆盖父类的方法，要求返回值、方法名和参数都相同，子类异常不能超出父类异常，子类访问级别不能低于父类访问级别。
   >
   > **方法重载**：重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但是参数却不相同，方法体也不相同。

